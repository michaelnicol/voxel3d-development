export var JointBoundingBoxActions; !function (e) { e.RETURN_MODE_FULL_DIRECTORY = "RETURN_MODE_FULL_DIRECTORY", e.RETURN_MODE_VOXELS_DIRECTORY = "RETURN_MODE_VOXELS_DIRECTORY", e.RETURN_MODE_VOXELS = "RETURN_MODE_VOXELS" }(JointBoundingBoxActions || (JointBoundingBoxActions = {})); export class JointBoundingBox { boundingBoxes = []; constructor(e) { this.boundingBoxes = e } isInside (e) { if (0 === this.boundingBoxes.length) return !1; for (let i = 0; i < this.boundingBoxes.length; i++)if (BoundingBox.isInside(e, this.boundingBoxes[i].boundingBoxPointData)) return !0; return !1 } getAllJointBoundingBoxes (e) { return this.boundingBoxes.reduce((i, t) => { if (e === JointBoundingBoxActions.RETURN_MODE_FULL_DIRECTORY) return i.push(JSON.parse(JSON.stringify(t))), i; if (e === JointBoundingBoxActions.RETURN_MODE_VOXELS_DIRECTORY) return i.push(JSON.parse(JSON.stringify(t.boundingBoxPointData))), i; if (e === JointBoundingBoxActions.RETURN_MODE_VOXELS) return i.push(...BoundingBox.compileBoundingDirectory(t.boundingBoxPointData)), i; throw TypeError("Invalid Mode") }, []) } } export var BoundingBoxPayloadModes; !function (e) { e.TYPE_BOUNDING_DIRECTORY = "TYPE_BOUNDING_DIRECTORY", e.TYPE_BOUNDING_POINTS = "TYPE_BOUNDING_POINTS" }(BoundingBoxPayloadModes || (BoundingBoxPayloadModes = {})); export class BoundingBox { static BOX_VERTICE_COUNT = 8; boundingBoxPointData = { 0: [0, 0, 0], 1: [0, 0, 0], 2: [0, 0, 0], 3: [0, 0, 0], 4: [0, 0, 0], 5: [0, 0, 0], 6: [0, 0, 0], 7: [0, 0, 0] }; yLow = -1; yHigh = -1; xLow = -1; xHigh = -1; zLow = -1; zHigh = -1; xRange = -1; yRange = -1; zRange = -1; biggestRangeLabaled = []; biggestRangeIndex = []; biggestRangeLabaledLow = []; biggestRangeLabaledHigh = []; constructor(e) { e.inputType === BoundingBoxPayloadModes.TYPE_BOUNDING_DIRECTORY ? this.setBoundingBox(e.boundingInputPayload) : e.inputType === BoundingBoxPayloadModes.TYPE_BOUNDING_POINTS && this.createBoundingBox(e.boundingInputPayload) } static getEmptyBoundingTemplate () { return { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [] } } setBoundingBox (e) { for (let i = 0; i < BoundingBox.BOX_VERTICE_COUNT; i++) { let t = String(i); this.boundingBoxPointData[t] = [...e[t]] } this.calculateRange(BoundingBox.compileBoundingDirectory(e)) } static isInside (e, i) { return e[0] >= i[0][0] && e[0] <= i[1][0] && e[1] >= i[0][1] && e[1] <= i[2][1] && e[2] >= i[0][2] && e[2] <= i[4][2] } static compileBoundingDirectory (e) { let i = []; for (let t = 0; t < BoundingBox.BOX_VERTICE_COUNT; t++) { let n = String(t); 3 === e[n].length && i.push([...e[n]]) } return i } calculateRange (e) { let i = e.reduce((e, i) => (e.push(i[0]), e), []).sort((e, i) => e - i), t = e.reduce((e, i) => (e.push(i[1]), e), []).sort((e, i) => e - i), n = e.reduce((e, i) => (e.push(i[2]), e), []).sort((e, i) => e - i); this.xLow = i[0], this.xHigh = i[i.length - 1], this.yLow = t[0], this.yHigh = t[t.length - 1], this.zLow = n[0], this.zHigh = n[n.length - 1], this.zRange = Math.abs(this.zHigh - this.zLow), this.yRange = Math.abs(this.yHigh - this.yLow), this.xRange = Math.abs(this.xHigh - this.xLow); let o = { xRange: { v: this.xRange, i: 0 }, yRange: { v: this.yRange, i: 1 }, zRange: { v: this.zRange, i: 2 } }; this.biggestRangeLabaled = ["xRange", "yRange", "zRange"].sort((e, i) => o[i].v - o[e].v), this.biggestRangeLabaledLow = this.biggestRangeLabaled.map(e => e.replace("Range", "Low")), this.biggestRangeLabaledHigh = this.biggestRangeLabaled.map(e => e.replace("Range", "High")), this.biggestRangeIndex = this.biggestRangeLabaled.map(e => o[e].i) } createBoundingBox (e) { if (e.length > 0) this.calculateRange(e), this.boundingBoxPointData[0] = [this.xLow, this.yLow, this.zLow], this.boundingBoxPointData[1] = [this.xHigh, this.yLow, this.zLow], this.boundingBoxPointData[2] = [this.xLow, this.yHigh, this.zLow], this.boundingBoxPointData[3] = [this.xHigh, this.yHigh, this.zLow], this.boundingBoxPointData[4] = [this.xLow, this.yLow, this.zHigh], this.boundingBoxPointData[5] = [this.xHigh, this.yLow, this.zHigh], this.boundingBoxPointData[6] = [this.xLow, this.yHigh, this.zHigh], this.boundingBoxPointData[7] = [this.xHigh, this.yHigh, this.zHigh]; else throw RangeError("Invalid BoundingBox.createBoundingBox argument: array2D must contain at least one XYZ voxel.") } static findEntryCount (e) { let i = 0; for (let t in e) e[t].length > 0 && i++; return i } static horizontalLineCheck (e, i, t, n, o) { return e[0] <= t[0] && i[0] >= t[0] && e[1] >= t[1] && e[1] <= n[1] && e[1] >= t[1] && e[2] >= n[2] && e[2] <= o[2] } static verticalLineCheck (e, i, t, n, o) { return e[0] >= t[0] && e[0] <= o[0] && e[1] >= t[1] && i[1] <= t[1] && e[2] >= t[2] && e[2] <= n[2] } static depthLineCheck (e, i, t, n, o) { return e[0] <= n[0] && e[0] >= o[0] && e[1] <= o[1] && e[1] >= t[1] && e[2] <= t[2] && i[2] >= t[2] } static #a = [[[0, 1], [2, 3], [6, 7], [4, 5]], [[0, 2], [1, 3], [4, 6], [5, 7]], [[2, 6], [3, 7], [0, 4], [1, 5]]]; static boundingBoxIntersect (e, i) { let t = BoundingBox.getEmptyBoundingTemplate(); for (let n of BoundingBox.#a[0]) { let o = e["" + n[0]], s = e["" + n[1]], r = i["" + n[0]], l = i["" + n[1]], g = BoundingBox.horizontalLineCheck(o, s, i[0], i[2], i[6]), u = BoundingBox.horizontalLineCheck(o, s, i[1], i[3], i[7]), a = BoundingBox.horizontalLineCheck(r, l, e[0], e[2], e[6]), B = BoundingBox.horizontalLineCheck(r, l, e[1], e[3], e[7]); g && (t["" + n[0]] = [i[0][0], o[1], o[2]]), u && (t["" + n[1]] = [i[1][0], s[1], s[2]]), a && (t["" + n[0]] = [e[0][0], r[1], r[2]]), B && (t["" + n[1]] = [e[1][0], l[1], l[2]]), BoundingBox.isInside(o, i) && (t["" + n[0]] = [...o]), BoundingBox.isInside(s, i) && (t["" + n[1]] = [...s]), BoundingBox.isInside(r, e) && (t["" + n[0]] = [...r]), BoundingBox.isInside(l, e) && (t["" + n[1]] = [...l]) } for (let d of BoundingBox.#a[1]) { let x = e["" + d[0]], h = e["" + d[1]], N = i["" + d[0]], O = i["" + d[1]], E = BoundingBox.verticalLineCheck(h, x, i[2], i[6], i[3]), c = BoundingBox.verticalLineCheck(h, x, i[0], i[4], i[5]), T = BoundingBox.verticalLineCheck(O, N, e[2], e[6], e[3]), f = BoundingBox.verticalLineCheck(O, N, e[0], e[4], e[5]); E && (t["" + d[1]] = [h[0], i[2][1], h[2]]), c && (t["" + d[0]] = [x[0], i[0][1], x[2]]), T && (t["" + d[1]] = [O[0], e[2][1], O[2]]), f && (t["" + d[0]] = [N[0], e[0][1], N[2]]), BoundingBox.isInside(x, i) && (t["" + d[0]] = [...x]), BoundingBox.isInside(h, i) && (t["" + d[1]] = [...h]), BoundingBox.isInside(N, e) && (t["" + d[0]] = [...N]), BoundingBox.isInside(O, e) && (t["" + d[1]] = [...O]) } for (let S of BoundingBox.#a[2]) { let D = e["" + S[0]], $ = e["" + S[1]], A = i["" + S[0]], I = i["" + S[1]], _ = BoundingBox.depthLineCheck(D, $, i[4], i[5], i[6]), P = BoundingBox.depthLineCheck(D, $, i[0], i[1], i[2]), R = BoundingBox.depthLineCheck(A, I, e[4], e[5], e[6]), p = BoundingBox.depthLineCheck(A, I, e[0], e[1], e[2]); _ && (t["" + S[1]] = [$[0], $[1], i[4][2]]), P && (t["" + S[0]] = [D[0], D[1], i[0][2]]), R && (t["" + S[1]] = [I[0], I[1], e[4][2]]), p && (t["" + S[0]] = [A[0], A[1], e[0][2]]), BoundingBox.isInside($, i) && (t["" + S[1]] = [...$]), BoundingBox.isInside(D, i) && (t["" + S[0]] = [...D]), BoundingBox.isInside(I, e) && (t["" + S[1]] = [...I]), BoundingBox.isInside(A, e) && (t["" + S[0]] = [...A]) } return this.correctBoundingBox(t) } static isDef = (e, i) => { for (let t = 0; t < i.length; t++)if (0 === e[i[t] + ""].length) return !1; return !0 }; static correctBoundingBox (e) { let i = BoundingBox.findEntryCount(e); if (i <= 1 || !(BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [4]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [5]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [4]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [5]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [4]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [5]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [5]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [5]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [5]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [5]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [4]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [5]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [5]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [6]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [5]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [6]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [4]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [5]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [5]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [5]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [6]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [5]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [5]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [6]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [0]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [4]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [5]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [4]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [5]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [4]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [5]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [5]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [5]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [5]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [1]) && BoundingBox.isDef(e, [6]) || BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [4]) || BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [5]) || BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [5]) || BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [6]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [4]) && BoundingBox.isDef(e, [7]) || BoundingBox.isDef(e, [2]) && BoundingBox.isDef(e, [5]) || BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [4]) || BoundingBox.isDef(e, [3]) && BoundingBox.isDef(e, [5]) && BoundingBox.isDef(e, [6]))) return [!1, e]; for (; i < 8;)!BoundingBox.isDef(e, [6, 3]) && BoundingBox.isDef(e, [7, 2]) && (e[3] = [e[7][0], e[7][1], e[2][2]], e[6] = [e[2][0], e[2][1], e[7][2]]), !BoundingBox.isDef(e, [2, 7]) && BoundingBox.isDef(e, [6, 3]) && (e[2] = [e[6][0], e[6][1], e[3][2]], e[7] = [e[3][0], e[3][1], e[6][2]]), !BoundingBox.isDef(e, [4, 1]) && BoundingBox.isDef(e, [5, 0]) && (e[4] = [e[0][0], e[0][1], e[5][2]], e[1] = [e[5][0], e[5][1], e[0][2]]), !BoundingBox.isDef(e, [5, 0]) && BoundingBox.isDef(e, [4, 1]) && (e[5] = [e[1][0], e[1][1], e[4][2]], e[0] = [e[4][0], e[4][2], e[1][2]]), !BoundingBox.isDef(e, [2, 1]) && BoundingBox.isDef(e, [3, 0]) && (e[2] = [e[0][0], e[3][1], e[3][2]], e[1] = [e[3][0], e[0][1], e[0][2]]), !BoundingBox.isDef(e, [3, 0]) && BoundingBox.isDef(e, [2, 1]) && (e[3] = [e[1][0], e[2][1], e[2][2]], e[0] = [e[2][0], e[1][1], e[1][2]]), !BoundingBox.isDef(e, [5, 6]) && BoundingBox.isDef(e, [4, 7]) && (e[5] = [e[7][0], e[4][1], e[4][2]], e[6] = [e[4][0], e[7][1], e[7][2]]), !BoundingBox.isDef(e, [4, 7]) && BoundingBox.isDef(e, [5, 6]) && (e[4] = [e[6][0], e[5][1], e[5][2]], e[7] = [e[5][0], e[6][1], e[6][2]]), !BoundingBox.isDef(e, [2, 4]) && BoundingBox.isDef(e, [6, 0]) && (e[2] = [e[0][0], e[6][1], e[0][2]], e[4] = [e[6][0], e[0][1], e[6][2]]), !BoundingBox.isDef(e, [6, 0]) && BoundingBox.isDef(e, [2, 4]) && (e[6] = [e[2][0], e[2][1], e[4][2]], e[0] = [e[2][0], e[4][1], e[2][2]]), !BoundingBox.isDef(e, [7, 1]) && BoundingBox.isDef(e, [3, 5]) && (e[7] = [e[3][0], e[3][1], e[5][2]], e[1] = [e[3][0], e[5][1], e[3][2]]), !BoundingBox.isDef(e, [3, 5]) && BoundingBox.isDef(e, [7, 1]) && (e[3] = [e[1][0], e[7][1], e[1][2]], e[5] = [e[1][0], e[1][1], e[7][2]]), !BoundingBox.isDef(e, [4, 4]) && BoundingBox.isDef(e, [7, 0]) && (e[4] = [e[0][0], e[0][1], e[7][2]]), !BoundingBox.isDef(e, [2, 2]) && BoundingBox.isDef(e, [1, 6]) && (e[2] = [e[6][0], e[6][1], e[1][2]]), !BoundingBox.isDef(e, [3, 3]) && BoundingBox.isDef(e, [2, 5]) && (e[3] = [e[5][0], e[2][1], e[2][2]]), !BoundingBox.isDef(e, [6, 6]) && BoundingBox.isDef(e, [4, 3]) && (e[6] = [e[4][0], e[3][1], e[4][2]]), i = BoundingBox.findEntryCount(e); return [!0, e] } } export class UUIDController { _objIDReferance; #b; constructor() { this.#b = [], this._objIDReferance = {} } randomChar () { let e = Math.random() > .5; return String.fromCodePoint(Math.floor(Math.random() * (e ? 26 : 10) + (e ? 97 : 48))) } #c () { let e = ""; for (let i = 1; i < 37; i++)e += this.randomChar(); return e } setReferenceEntry (e, i) { this._objIDReferance[e] = i } removeReferenceEntry (e) { delete this._objIDReferance[e] } getNewID () { let e = this.#c(); for (; -1 !== this.#b.indexOf(e);)e = this.#c(); return this.#b.push(e), e } removeID (e) { return this.#b = this.#b.filter(i => e !== i), delete this._objIDReferance[e], [...this.#b] } getAllID () { return [...this.#b] } addID (e) { return -1 === this.#b.indexOf(e) && (this.#b.push(e), !0) } delete () { this.#b = [], this._objIDReferance = {} } } export class BaseObject { controller; uuid; _fillVoxels; _origin; jointBoundingBox; boundingBoxMeta; sortedFillVoxelsDirectory; constructor(e) { this.controller = e.controller, this.uuid = e.controller.getNewID(), this._fillVoxels = [[0, 0, 0]], this._origin = [...e.origin], this.boundingBoxMeta = new BoundingBox({ boundingInputPayload: BaseObject.addOrigin(this._fillVoxels, this._origin), inputType: BoundingBoxPayloadModes.TYPE_BOUNDING_POINTS }); let i = BaseObject.sortFillVoxels(this.getFillVoxels(), this.boundingBoxMeta); this.sortedFillVoxelsDirectory = i.sortedFillVoxelsDirectory, this.jointBoundingBox = i.jointBoundingBox } static convertPointsToDemos (e) { return JSON.stringify(e).replace(/\]/g, ")").replace(/\[/g, "(").replace(/\({2}/g, "(").replace(/\){2}/g, ")") } static sortPoints (e) { return e.sort((e, i) => e[2] - i[2]).sort((e, i) => e[1] - i[1]).sort((e, i) => e[0] - i[0]) } static addOrigin (e, i) { return e.reduce((e, t) => (e.push([t[0] + i[0], t[1] + i[1], t[2] + i[2]]), e), []) } getOrigin () { return [...this._origin] } getFillVoxels () { return BaseObject.addOrigin(this._fillVoxels, this.getOrigin()) } calculateBoundingBox () { if (this.sortedFillVoxelsDirectory = {}, 0 === this._fillVoxels.length) this.boundingBoxMeta = BoundingBox.getEmptyBoundingTemplate(), this.jointBoundingBox = new JointBoundingBox([]); else { this.boundingBoxMeta = new BoundingBox({ inputType: BoundingBoxPayloadModes.TYPE_BOUNDING_POINTS, boundingInputPayload: this.getFillVoxels() }); let e = BaseObject.sortFillVoxels(this.getFillVoxels(), this.boundingBoxMeta); this.sortedFillVoxelsDirectory = e.sortedFillVoxelsDirectory, this.jointBoundingBox = e.jointBoundingBox } } setOrigin (e) { this._origin = [...e], this.calculateBoundingBox() } static sortFillVoxels (e, i) { let t = {}, n = []; if (0 === e.length) return { jointBoundingBox: new JointBoundingBox([]), sortedFillVoxelsDirectory: t }; let { biggestRangeIndex: o, biggestRangeLabaledHigh: s, biggestRangeLabaledLow: r } = i; for (let l = i[r[0]]; l <= i[s[0]]; l++)t[l] = []; for (let g = 0; g < e.length; g++) { let u = e[g]; t[u[o[0]]].push([...u]) } for (let a of Object.keys(t)) { let B = Number(a); BaseObject.sortPoints(t[B]), t[B].length >= 1 && n.push(new BoundingBox({ inputType: BoundingBoxPayloadModes.TYPE_BOUNDING_POINTS, boundingInputPayload: t[B] })) } return { jointBoundingBox: new JointBoundingBox(n), sortedFillVoxelsDirectory: t } } findPointFromObject (e) { if (0 === this._fillVoxels.length) return [-1, -1]; let i = e[this.boundingBoxMeta.biggestRangeIndex["0"]]; if (-1 === Object.keys(this.sortedFillVoxelsDirectory).indexOf("" + i)) return [-1, -1]; let t = this.sortedFillVoxelsDirectory[i]; return [i, BaseObject.#d(BaseObject.sortPoints(t), 0, Math.floor((t.length - 1) / 2), t.length - 1, e, 0)] } static findPointFromArray (e, i) { return BaseObject.#d(BaseObject.sortPoints(e), 0, Math.floor((e.length - 1) / 2), e.length - 1, i, 0) } static #d (t, n, o, s, r, l) { if (n > s || 0 === t.length) return -1; if (t[o][l] === r[l]) { if (2 === l) return o; l += 1; for (let g = 0; g < l; g++)if (t[o][g] != r[g]) return BaseObject.#d(t, n, o, s, r, g - 1 >= 0 ? g - 1 : 0); return BaseObject.#d(t, n, o, s, r, l) } if (t[o][l] < r[l]) return o = (n = o + 1) + Math.floor((s - n) / 2), BaseObject.#d(t, n, o, s, r, l); if (t[o][l] > r[l]) return o = n + Math.floor(((s = o - 1) - n) / 2), BaseObject.#d(t, n, o, s, r, l); throw TypeError("Binary Search Is Lost finding Voxel" + JSON.stringify(r) + " in Voxel[] " + JSON.stringify(t)) } static graph3DParametric = (e, i, t, n, o, s) => { let r = o - i, l = n - e, g = s - t, u = { x: l < 0 ? -1 : 1, y: r < 0 ? -1 : 1, z: g < 0 ? -1 : 1 }; l < 1 && l > -1 && (u.x = 0), r < 1 && r > -1 && (u.y = 0), g < 1 && g > -1 && (u.z = 0), l = Math.abs(l), r = Math.abs(r), g = Math.abs(g); let a; if (0 === u[a = r >= g && r >= l ? "y" : l >= r && l >= g ? "x" : "z"]) return [[n, o, s]]; let B = Math.max(r, l, g), d = "y" === a ? i : "x" === a ? e : t, x = e, h = i, N = t, O = [], E = 0, c = 0, T = 0; for (let f = d; 1 === u[a] ? f <= d + B : f >= d - B; f += u[a]) { if ("x" === a) { c >= l && (c -= l, h += u.y), T >= l && (T -= l, N += u.z), c += r, T += g, O.push([f, h, N]); continue } if ("y" === a) { E >= r && (E -= r, x += u.x), T >= r && (T -= r, N += u.z), E += l, T += g, O.push([x, f, N]); continue } if ("z" === a) { E >= g && (E -= g, x += u.x), c >= g && (c -= g, h += u.y), c += r, E += l, O.push([x, h, f]); continue } } return O }; static compare2d (e, i) { if (e.length !== i.length) return !1; if (!(Array.isArray(e) && Array.isArray(i))) return console.warn("compare2d | One or more of the inputs is not an array |" + new Date), !1; for (let t = 0; t < e.length; t++)if (e[t] !== i[t]) return !1; return !0 } static push2D (e, i) { for (let t of e) i.push([...t]); return i } static deepCopy (e) { return JSON.parse(JSON.stringify(e)) } delete () { this.controller.removeID(this.uuid), this._fillVoxels = [], this.calculateBoundingBox(), this.uuid = "" } } export class Line extends BaseObject { _endPoints; constructor(e) { super({ controller: e.controller, origin: e.origin }), this.controller.setReferenceEntry(this.uuid, this), this._endPoints = BaseObject.deepCopy(e.endPoints), this._fillVoxels = [...this._endPoints], this.calculateBoundingBox() } generateLine () { this._fillVoxels = []; let { biggestRangeIndex: e } = this.boundingBoxMeta, i = BaseObject.graph3DParametric(...this._endPoints[0], ...this._endPoints[1]); BaseObject.push2D(i, this._fillVoxels), BaseObject.sortPoints(this._fillVoxels), this.calculateBoundingBox() } getVerticeVoxels () { return BaseObject.addOrigin(this._endPoints, this._origin) } changeEndPoints (e) { this._endPoints = [e[0], e[1]], this._fillVoxels = [...this._endPoints], this.calculateBoundingBox() } } export class Layer extends BaseObject { _verticesArray; edgeDirectory; _edgeVoxels; constructor(e) { super({ controller: e.controller, origin: e.origin }), this.controller.setReferenceEntry(this.uuid, this), this._verticesArray = BaseObject.deepCopy(e.verticesArray), this._fillVoxels = [...this._verticesArray], this.calculateBoundingBox(), this.edgeDirectory = {}, this._edgeVoxels = [...this._verticesArray] } changeVertices (e) { return this._verticesArray = BaseObject.deepCopy(e), this._fillVoxels = [...this._verticesArray], this.calculateBoundingBox(), this.edgeDirectory = {}, this._edgeVoxels = [...this._verticesArray], this } generateEdges () { this._fillVoxels = [], this._edgeVoxels = [...this._verticesArray], this.calculateBoundingBox(); let e = new Line({ endPoints: [[0, 0, 0], [0, 0, 0]], controller: this.controller, origin: this.getOrigin() }), i = new CompositeVoxelCollection({ origin: this.getOrigin(), controller: this.controller, variableNames: { [e.uuid]: e, [this.uuid]: this }, log: !1 }); i.setEquation(e.uuid + i.tokens.SUBTRACTION_OP + this.uuid), this.edgeDirectory = {}; for (let t = 0; t < this._verticesArray.length; t++) { let n = t, o, s = `V${n}V${o = t + 1 === this._verticesArray.length ? 0 : t + 1}`; e.changeEndPoints([this._verticesArray[n], this._verticesArray[o]]), e.generateLine(); let r = e.getFillVoxels(); this.edgeDirectory[s] = r, BaseObject.push2D(i.interpretAST().getFillVoxels(), this._fillVoxels), this.calculateBoundingBox() } return e.delete(), i.delete(), this._edgeVoxels = BaseObject.push2D(this._fillVoxels, []), this } fillPolygon () { this._fillVoxels = [], this.calculateBoundingBox(); let e = new Layer({ verticesArray: [], origin: this.getOrigin(), controller: this.controller }); for (let i of Object.keys(this.sortedFillVoxelsDirectory)) { let t = Number(i), n = this.sortedFillVoxelsDirectory[t]; e.changeVertices(n).generateEdges(); let o = []; for (let s of Object.keys(e.edgeDirectory)) { let r = e.edgeDirectory[s]; targetLineLoop: for (let l = 1; l < r.length - 1; l++) { for (let g = 0; g < n.length; g++)if (JSON.stringify(r[l]) === JSON.stringify(n[g])) continue targetLineLoop; for (let u = 0; u < o.length; u++)if (JSON.stringify(r[l]) === JSON.stringify(o[u])) continue targetLineLoop; o.push(r[l]), this._fillVoxels.push([...r[l]]) } } } return e.delete(), this } getEdgeVoxels () { return BaseObject.addOrigin(this._edgeVoxels, this._origin) } getVerticeVoxels () { return BaseObject.addOrigin(this._verticesArray, this._origin) } delete () { this.controller.removeID(this.uuid), this._fillVoxels = [], this._edgeVoxels = [], this.calculateBoundingBox(), this.uuid = "" } } let SYNTAX_TOKENS = { UNIVERSAL_SET: "Ω", NULL_SET: "∅", UNION_OP: "∪", INTERSECTION_OP: "∩", SUBTRACTION_OP: "-", SYMM_DIFF_OP: "⊕", NEGATION_OP: "!", OPEN_PER: "(", CLOSE_PER: ")", IDENTATION: "-", NOT_PLACE_HOLDER: "@" }; export var SetOperationsParserAction; !function (e) { e.TEST_MODE = "TEST_MODE", e.MATCH_MODE = "MATCH_MODE" }(SetOperationsParserAction || (SetOperationsParserAction = {})); let SYNTAX_REGEX = { CONVERSION_REGEX: RegExp(`\\${SYNTAX_TOKENS.NEGATION_OP}*\\${SYNTAX_TOKENS.OPEN_PER}|\\${SYNTAX_TOKENS.CLOSE_PER}|\\${SYNTAX_TOKENS.NEGATION_OP}*[a-z${SYNTAX_TOKENS.UNIVERSAL_SET}${SYNTAX_TOKENS.NULL_SET}0-9]+|[${SYNTAX_TOKENS.INTERSECTION_OP}${SYNTAX_TOKENS.SYMM_DIFF_OP}${SYNTAX_TOKENS.UNION_OP}${SYNTAX_TOKENS.SUBTRACTION_OP}]`, "gi"), INVALID_NEGATION_CLOSE_PER_REGEX: RegExp(`\\${SYNTAX_TOKENS.NEGATION_OP}+\\${SYNTAX_TOKENS.CLOSE_PER}`, "gi"), CLOSE_PER_COUNT_REGEX: RegExp(`\\${SYNTAX_TOKENS.CLOSE_PER}`, "gi"), OPEN_PER_COUNT_REGEX: RegExp(`\\${SYNTAX_TOKENS.OPEN_PER}`, "gi"), INVALID_ENDING_REGEX: RegExp(`[${SYNTAX_TOKENS.OPEN_PER}${SYNTAX_TOKENS.NEGATION_OP}${SYNTAX_TOKENS.INTERSECTION_OP}${SYNTAX_TOKENS.SYMM_DIFF_OP}${SYNTAX_TOKENS.UNION_OP}${SYNTAX_TOKENS.SUBTRACTION_OP}]$`), INVALID_OP_DIRECT_NEGATE_REGEX: RegExp(`\\${SYNTAX_TOKENS.NEGATION_OP}+[${SYNTAX_TOKENS.SUBTRACTION_OP}${SYNTAX_TOKENS.SYMM_DIFF_OP}]`, "gi"), INVALID_JUNCTION_REGEX: RegExp(`[${SYNTAX_TOKENS.UNIVERSAL_SET}${SYNTAX_TOKENS.NULL_SET}${SYNTAX_TOKENS.CLOSE_PER}a-z]+\\${SYNTAX_TOKENS.OPEN_PER}|\\${SYNTAX_TOKENS.OPEN_PER}\\${SYNTAX_TOKENS.CLOSE_PER}|[${SYNTAX_TOKENS.INTERSECTION_OP}${SYNTAX_TOKENS.SYMM_DIFF_OP}${SYNTAX_TOKENS.UNION_OP}${SYNTAX_TOKENS.SUBTRACTION_OP}]+\\${SYNTAX_TOKENS.CLOSE_PER}|[${SYNTAX_TOKENS.UNIVERSAL_SET}${SYNTAX_TOKENS.NULL_SET}]{2,}`, "gi"), VALID_CHAR_REGEX: RegExp(`\\s|[a-z]|[${SYNTAX_TOKENS.UNIVERSAL_SET}${SYNTAX_TOKENS.NULL_SET}${SYNTAX_TOKENS.UNION_OP}${SYNTAX_TOKENS.INTERSECTION_OP}${SYNTAX_TOKENS.SYMM_DIFF_OP}${SYNTAX_TOKENS.NEGATION_OP}${SYNTAX_TOKENS.OPEN_PER}${SYNTAX_TOKENS.CLOSE_PER}${SYNTAX_TOKENS.SUBTRACTION_OP}]|\\d`, "gi") }, OPS = { [SYNTAX_TOKENS.OPEN_PER]: 3, [SYNTAX_TOKENS.CLOSE_PER]: 3, [SYNTAX_TOKENS.NEGATION_OP]: 2, [SYNTAX_TOKENS.SYMM_DIFF_OP]: 1, [SYNTAX_TOKENS.SUBTRACTION_OP]: 0, [SYNTAX_TOKENS.INTERSECTION_OP]: 0, [SYNTAX_TOKENS.UNION_OP]: 0 }; export class SetOperationsParser { constructor() { } static getAllRegex () { return Object.keys(SYNTAX_REGEX).reduce((e, i) => (e[i] = RegExp(SYNTAX_REGEX[i].source, "gi"), e), {}) } static accessOPS (e) { return OPS[e] } static getOPS () { return Object.assign({}, OPS) } static getSymbols () { return { UNIVERSAL_SET: SYNTAX_TOKENS.UNIVERSAL_SET, NULL_SET: SYNTAX_TOKENS.NULL_SET, UNION_OP: SYNTAX_TOKENS.UNION_OP, INTERSECTION_OP: SYNTAX_TOKENS.INTERSECTION_OP, SUBTRACTION_OP: SYNTAX_TOKENS.SUBTRACTION_OP, SYMM_DIFF_OP: SYNTAX_TOKENS.SYMM_DIFF_OP, NEGATION_OP: SYNTAX_TOKENS.NEGATION_OP, OPEN_PER: SYNTAX_TOKENS.OPEN_PER, CLOSE_PER: SYNTAX_TOKENS.CLOSE_PER, IDENTATION: SYNTAX_TOKENS.IDENTATION } } static useRegex (e, i, t) { let n = RegExp(SYNTAX_REGEX[`${e}`].source, "gi"), o, s = !1; if (t === SetOperationsParserAction.TEST_MODE) return s = n.test(i), n.lastIndex = 0, s; if (t === SetOperationsParserAction.MATCH_MODE) return o = i.match(n), n.lastIndex = 0, null === o ? [] : o; throw TypeError("Invalid Action: " + t) } static validateEquation (e) { e = e.split("").filter(e => !/\s/.test(e)).join(""); let i; for (let t = 0; t < e.length; t++)if (!(i = SetOperationsParser.useRegex("VALID_CHAR_REGEX", e[t], SetOperationsParserAction.TEST_MODE))) throw TypeError(`VALID_CHAR_REGEX | Unable to validate equationString "${e}": Invalid token ${e[t]}`); if ((i = SetOperationsParser.useRegex("INVALID_NEGATION_CLOSE_PER_REGEX", e, SetOperationsParserAction.TEST_MODE)) instanceof Array && i.length > 0) throw TypeError(`INVALID_NEGATION_CLOSE_PER_REGEX | Unable to validate equationString "${e}": Cannot pre negate "${SYNTAX_TOKENS.NEGATION_OP}" closing grouping syntax "${SYNTAX_TOKENS.CLOSE_PER}" with tokens "${i[0]}" `); let n = SetOperationsParser.useRegex("CLOSE_PER_COUNT_REGEX", e, SetOperationsParserAction.MATCH_MODE), o = SetOperationsParser.useRegex("OPEN_PER_COUNT_REGEX", e, SetOperationsParserAction.MATCH_MODE); if (o instanceof Array && n instanceof Array && n.length !== o.length) throw TypeError(`CLOSE_PER_COUNT_REGEX, OPEN_PER_COUNT_REGEX | Unable to validate equationString "${e}": unequal amount of starting and ending grouping syntax`); if ((i = SetOperationsParser.useRegex("INVALID_ENDING_REGEX", e, SetOperationsParserAction.MATCH_MODE)) instanceof Array && i.length > 0) throw TypeError(`INVALID_ENDING_REGEX | Unable to validate equationString "${e}": Ends with operator, negation or opening grouping syntax token: "${i}"`); if ((i = SetOperationsParser.useRegex("INVALID_OP_DIRECT_NEGATE_REGEX", e, SetOperationsParserAction.MATCH_MODE)) instanceof Array && i.length > 0) throw TypeError(`INVALID_OP_DIRECT_NEGATE_REGEX | Unable to validate equationString "${e}": Cannot directly negate symmetric difference or subtraction operator "${i}"`); if ((i = SetOperationsParser.useRegex("INVALID_JUNCTION_REGEX", e, SetOperationsParserAction.MATCH_MODE)) instanceof Array && i.length > 0) throw TypeError(`INVALID_JUNCTION_REGEX | Unable to validate equationString "${e}": Invalid Junction between two tokens "${i}"`); return e = (e = (e = (e = (e = e.replaceAll(`${SYNTAX_TOKENS.NEGATION_OP}${SYNTAX_TOKENS.NEGATION_OP}`, "")).replaceAll(`${SYNTAX_TOKENS.NEGATION_OP}${SYNTAX_TOKENS.INTERSECTION_OP}`, `${SYNTAX_TOKENS.UNION_OP}`)).replaceAll(`${SYNTAX_TOKENS.NEGATION_OP}${SYNTAX_TOKENS.UNION_OP}`, `${SYNTAX_TOKENS.INTERSECTION_OP}`)).replaceAll(`${SYNTAX_TOKENS.NEGATION_OP}${SYNTAX_TOKENS.UNIVERSAL_SET}`, `${SYNTAX_TOKENS.NULL_SET}`)).replaceAll(`${SYNTAX_TOKENS.NEGATION_OP}${SYNTAX_TOKENS.NULL_SET}`, `${SYNTAX_TOKENS.UNIVERSAL_SET}`), o instanceof Array && n instanceof Array && 1 === n.length && 1 === o.length && e[0] === SYNTAX_TOKENS.OPEN_PER && e[e.length - 1] === SYNTAX_TOKENS.CLOSE_PER && (e = e.replace(`${SYNTAX_TOKENS.OPEN_PER}`, "").replace(`${SYNTAX_TOKENS.CLOSE_PER}`, "")), SetOperationsParser.useRegex("CONVERSION_REGEX", e, SetOperationsParserAction.MATCH_MODE) } static _distrubuteNegate (e, i, t) { let n = ""; for (let o = 0; o < t; o++)n += SYNTAX_TOKENS.IDENTATION; i && console.log(n + "Distrubting negation to: " + JSON.stringify(e)); for (let s = 0; s < e.length; s++) { if (e[s] === SYNTAX_TOKENS.SYMM_DIFF_OP) throw TypeError("Processing error: can not directly negate SYMM_DIFF_OP: " + e[s]); if (Array.isArray(e[s]) && e[s]) i && console.log(n + " Activiated distribution to sub-AST"), e[s] = SetOperationsParser._distrubuteNegate(e[s], i, t); else if (e[s] === SYNTAX_TOKENS.UNION_OP) e[s] = SYNTAX_TOKENS.INTERSECTION_OP; else if (e[s] === SYNTAX_TOKENS.INTERSECTION_OP) e[s] = SYNTAX_TOKENS.UNION_OP; else if (e[s] === SYNTAX_TOKENS.NEGATION_OP) e[s] = ""; else if ("string" == typeof e[s] && e[s].split("")[0] === SYNTAX_TOKENS.NEGATION_OP) e[s] = e[s].slice(1, e[s].length); else if (e[s] === SYNTAX_TOKENS.SUBTRACTION_OP) { i && console.log(n + "Subtraction negation detected, switching to union and halting"), e[s] = SYNTAX_TOKENS.UNION_OP; break } else e[s] === SYNTAX_TOKENS.UNIVERSAL_SET ? e[s] = SYNTAX_TOKENS.NULL_SET : e[s] === SYNTAX_TOKENS.NULL_SET ? e[s] = SYNTAX_TOKENS.UNIVERSAL_SET : (e[s] = [SYNTAX_TOKENS.UNIVERSAL_SET, SYNTAX_TOKENS.SUBTRACTION_OP, e[s]], console.log(n + "Setting to Universal minus " + e[s])) } return e } static generateAST (e, i, t = 0) { let n = ""; if (i) { for (let o = 0; o <= t; o++)n += SYNTAX_TOKENS.IDENTATION; console.log(n + "Input EQ: " + JSON.stringify(e)), console.log(n + "Length of EQ: " + e.length), t += 1 } let s = -1, r = -1, l = -1, g = -1, u = [], a = [], B = [], d = []; if (e.length <= 2) return i && console.log(n + "Equation length is <= 2, returning equation"), [...e]; for (let x = 0; x < e.length; x++) { let h = e[x]; if (i && console.log(n + "Checking Token: " + JSON.stringify(h)), !Array.isArray(h) && h.startsWith("!!")) { i && console.log(n + "Token starts with n >= 2 negation: " + h); let N = h.split(""); h = (N.slice(0, N.length - 1).length % 2 == 0 ? "" : SYNTAX_TOKENS.NEGATION_OP) + N[N.length - 1], i && console.log(n + "Converted Token starts with n >= 2 negation: " + h), e[x] = h } h === SYNTAX_TOKENS.SYMM_DIFF_OP && d.push(x), !Array.isArray(h) && h.startsWith(SYNTAX_TOKENS.NEGATION_OP) && (i && console.log(n + "Token starts with negation"), (h = h.split(""))[1] === SYNTAX_TOKENS.OPEN_PER && (i && console.log(n + "Token is negating open Grouping"), B.push(x)), h = h[1], !OPS.hasOwnProperty(h) && (e[x] = [SYNTAX_TOKENS.UNIVERSAL_SET, SYNTAX_TOKENS.SUBTRACTION_OP, h], i && console.log(n + "Activated Token is negating set: " + JSON.stringify(e[x])))), h === SYNTAX_TOKENS.OPEN_PER ? u.push(x) : h == SYNTAX_TOKENS.CLOSE_PER ? a.push(x) : OPS.hasOwnProperty(h) && (void 0 === g || OPS[h] > g) && !(h === SYNTAX_TOKENS.SYMM_DIFF_OP && e[x + 1] === `${SYNTAX_TOKENS.NEGATION_OP}${SYNTAX_TOKENS.OPEN_PER}`) && (i && console.log(n + "Activated operation identification loop condition"), g = OPS[h], r = x + 1, s = x - 1, l = x) } if (3 === e.length && 0 === u.length && 0 === a.length) { if (i && console.log(n + "Activated EQ Length is 3"), JSON.stringify(e[0]) === JSON.stringify(e[2])) { if (e[1] === SYNTAX_TOKENS.INTERSECTION_OP || e[1] === SYNTAX_TOKENS.UNION_OP) return i && console.log(n + "Activated L3 Intersection or Union with self, returning self"), 1 === t ? [e[0]] : e[0]; if (e[1] === SYNTAX_TOKENS.SYMM_DIFF_OP || e[1] === SYNTAX_TOKENS.SUBTRACTION_OP) return i && console.log(n + "Activated L3 Symmertic Difference or subtraction with itself returning null"), 1 === t ? [SYNTAX_TOKENS.NULL_SET] : SYNTAX_TOKENS.NULL_SET } if (e[0] === SYNTAX_TOKENS.NULL_SET || e[2] === SYNTAX_TOKENS.NULL_SET) { if (e[1] === SYNTAX_TOKENS.INTERSECTION_OP) return i && console.log(n + "L3: Activated intersection null"), SYNTAX_TOKENS.NULL_SET; if (e[1] === SYNTAX_TOKENS.UNION_OP || e[1] === SYNTAX_TOKENS.SYMM_DIFF_OP) return i && console.log(n + "L3: Activated union null"), e[0] === SYNTAX_TOKENS.NULL_SET ? 1 === t ? [e[2]] : e[2] : 1 === t ? [e[0]] : e[0]; if (e[1] === SYNTAX_TOKENS.SUBTRACTION_OP) return (i && console.log(n + "L3: Activiated set subtraction with null set"), e[0] === SYNTAX_TOKENS.NULL_SET) ? 1 === t ? [SYNTAX_TOKENS.NULL_SET] : SYNTAX_TOKENS.NULL_SET : 1 === t ? [e[0]] : e[0] } return e[1] === SYNTAX_TOKENS.SUBTRACTION_OP && e[2] === SYNTAX_TOKENS.UNIVERSAL_SET ? (i && console.log(n + "L3: Activated minus universal set equals null"), 1 === t ? [SYNTAX_TOKENS.NULL_SET] : SYNTAX_TOKENS.NULL_SET) : e[1] === SYNTAX_TOKENS.UNION_OP && (e[0] === SYNTAX_TOKENS.UNIVERSAL_SET || e[2] === SYNTAX_TOKENS.UNIVERSAL_SET) ? (i && console.log(n + "L3: Activated union universal set equals universal"), 1 === t ? [SYNTAX_TOKENS.UNIVERSAL_SET] : SYNTAX_TOKENS.UNIVERSAL_SET) : e[1] === SYNTAX_TOKENS.INTERSECTION_OP && (e[0] === SYNTAX_TOKENS.UNIVERSAL_SET || e[2] === SYNTAX_TOKENS.UNIVERSAL_SET) ? (i && console.log(n + "L3: Activated intersection universal set"), e[0] === SYNTAX_TOKENS.UNIVERSAL_SET ? 1 === t ? [e[2]] : e[2] : 1 === t ? [e[0]] : e[0]) : (i && console.log(n + "L3: Returning eq"), [...e]) } if (d.length > 0 && i && console.log(n + "Amount of Symmertries: " + d.length), u.length !== a.length) throw console.log(e, u, a), Error("Invalid Amount of Grouping"); let O = {}, E = 0, c = [...u, ...a]; for (; c.length > 0;) { let T = -1, f = -1; c = [...u, ...a]; startLoop: for (let S of u) { T = S; endLoop: for (let D of a) if (!(D <= S)) { for (let $ of c) if ($ > S && $ < D) continue endLoop; E++, f = D, O[`${E}`] = { i: [T, f], n: e[T] === `${SYNTAX_TOKENS.NEGATION_OP}${SYNTAX_TOKENS.OPEN_PER}` }, u = u.filter((e, i) => i !== u.indexOf(T)), a = a.filter((e, i) => i !== a.indexOf(f)); break startLoop } } } let A = -1, I = -1, _ = -1, P = -1, R = Object.keys(O); if (R.length > 0) { A = O["1"].i[0], I = O["1"].i[1]; let p = -1; for (let V of R) O[V].n && O[V].i[0] <= A && O[V].i[1] >= I && (Number(V) < p || -1 === p) && (p = Number(V), _ = O[V].i[0], P = O[V].i[1]) } if (i && (console.log(n + "Grouping Ranking" + JSON.stringify(O)), console.log(n + "Target Opening Grouping Index " + A), console.log(n + "Target Closing Grouping Index " + I), console.log(n + "Target Negated Opening Grouping Index " + _), console.log(n + "Target Negated Opening Grouping Index " + P)), -1 !== P && -1 != _) { i && console.log(n + "Activiated Symmertric Difference negation check"); for (let y = 0; y < d.length; y++)if (d[y] > _ && d[y] < P) return i && console.log(n + `Symmertic difference at index ${d[y]} is being negated.`), e[_] = `${SYNTAX_TOKENS.OPEN_PER}`, SetOperationsParser.generateAST([...e.slice(0, _), [SYNTAX_TOKENS.UNIVERSAL_SET, SYNTAX_TOKENS.SUBTRACTION_OP, SetOperationsParser.generateAST([...e.slice(_ + 1, P)], i, t)], ...e.slice(P + 1, e.length)], i, t) } else -1 !== P && -1 != _ ? (i && console.log(n + "Activated Negated Grouping is startIndex"), e[A] = SYNTAX_TOKENS.OPEN_PER, e = [...e.slice(0, A), ...this._distrubuteNegate(e.slice(A + 1, I), i, t), ...e.slice(I + 1, e.length)], i && console.log(n + "Combined and negated equation: " + JSON.stringify(e))) : -1 !== A && -1 !== I ? (i && console.log(n + "Activated startPerArray Length Condition because their are " + u.length + " opening grouping syntax, target grouping syntax is at EQ startIndex: " + A), e = [...e.slice(0, A), SetOperationsParser.generateAST(e.slice(A + 1, I), i, t), ...e.slice(I + 1, e.length)]) : (i && console.log(n + "Operation Index: " + l), e = [...e.slice(0, s), SetOperationsParser.generateAST([e[s], e[l], e[r]], i, t), ...e.slice(r + 1, e.length)]); let L = SetOperationsParser.generateAST(e, i, t); return i && console.log(n + "Equation is finalized, pushing to the tree"), console.log(n + JSON.stringify(L)), L } } export class SetOperationsEquation { equationString; log; validEquationArray; equationAST = []; constructor(e, i) { this.equationString = e, this.log = i, this.validEquationArray = [] } changeEquation (e) { this.equationString = e, this.validEquationArray = [], this.equationAST = [] } validateEquation () { this.validEquationArray = SetOperationsParser.validateEquation(this.equationString) } generateAST () { this.equationAST = SetOperationsParser.generateAST([...this.validEquationArray], this.log, 0) } getAST () { return JSON.parse(JSON.stringify(this.equationAST)) } } export class VoxelCollection extends BaseObject { constructor(e) { super({ controller: e.controller, origin: e.origin }), this._fillVoxels = [], BaseObject.push2D(e.fillVoxels, this._fillVoxels), this.calculateBoundingBox() } setFillVoxels (e) { return this._fillVoxels = [], BaseObject.push2D(e, this._fillVoxels), this.calculateBoundingBox(), this } addFillVoxels (e) { return BaseObject.push2D(e, this._fillVoxels), this.calculateBoundingBox(), this } } export class CompositeVoxelCollection extends BaseObject { equationInstance; virtualCache; tokens; variableNames; constructor(e) { for (let i of (super({ controller: e.controller, origin: e.origin }), this.variableNames = e.variableNames, this.equationInstance = new SetOperationsEquation("", e.log), this._fillVoxels = [], Object.keys(this.variableNames))) BaseObject.push2D(this.variableNames[i].getFillVoxels(), this._fillVoxels); this.calculateBoundingBox(), this.tokens = SetOperationsParser.getSymbols(), this.virtualCache = {}, this.resetVirtualCache() } delete () { this.controller.removeID(this.uuid), this._fillVoxels = [], this.calculateBoundingBox(), this.resetVirtualCache(), this.uuid = "" } resetVirtualCache () { let e = Object.keys(this.virtualCache); for (let i = 0; i < e.length; i++)(e[i] !== this.tokens.UNIVERSAL_SET || e[i] !== this.tokens.NULL_SET) && (this.virtualCache[e[i]].delete(), delete this.virtualCache[e[i]]); let t = []; for (let n of Object.keys(this.variableNames)) BaseObject.push2D(this.variableNames[n].getFillVoxels(), t); return this.virtualCache = { [this.tokens.UNIVERSAL_SET]: new VoxelCollection({ controller: this.controller, fillVoxels: t, origin: this._origin }), [this.tokens.NULL_SET]: new VoxelCollection({ controller: this.controller, fillVoxels: [], origin: this._origin }) }, this } changeNames (e) { return this.variableNames = Object.assign({}, e), this.resetVirtualCache(), this } setEquation (e) { return this.equationInstance.changeEquation(e), this.equationInstance.validateEquation(), this.equationInstance.generateAST(), this } #e (u, a) { let B = "", d = "", x = "", h = ""; for (let N = 0; N < a; N++)h += "-"; for (let O = 0; O < u.length; O++)Array.isArray(u[O]) && (u[O] = this.#e(u[O], a + 1)); B = u[0], 1 !== u.length && (d = u[1], x = u[2]); try { if ("string" == typeof B && (B === this.tokens.UNIVERSAL_SET || B === this.tokens.NULL_SET) ? B = this.virtualCache[B] : "string" == typeof B && (B = this.variableNames[B]), void 0 === B) throw TypeError("Token 1 undefined") } catch (E) { throw console.warn("Interpet Error: logging heap and names"), console.warn(this.virtualCache), console.warn(this.variableNames), ReferenceError("Unable to find the heap address for token1: " + B) } if (1 === u.length) return B; if (2 === u.length) throw console.warn("Interpet Error: logging heap and names"), console.warn(this.virtualCache), console.warn(this.variableNames), ReferenceError("Invalid sub-equation length two from AST layer: " + B); try { if ("string" == typeof x && (x === this.tokens.UNIVERSAL_SET || x === this.tokens.NULL_SET) ? x = this.virtualCache[x] : "string" == typeof x && (x = this.variableNames[x]), void 0 === x) throw TypeError("Token 2 undefined") } catch (c) { throw console.warn("Interpet Error: logging heap and names"), console.warn(this.virtualCache), console.warn(this.variableNames), ReferenceError("Unable to find the heap address or variableNames address for token2: " + x) } let T = B.uuid + d + x.uuid, f = x.uuid + d + B.uuid, S = Object.keys(this.virtualCache); if (-1 !== S.indexOf(T)) return this.virtualCache[T]; if ((d === this.tokens.UNION_OP || d === this.tokens.INTERSECTION_OP) && -1 !== S.indexOf(f)) return this.virtualCache[f]; if (B.uuid === x.uuid) return d === this.tokens.INTERSECTION_OP || d === this.tokens.UNION_OP ? this.virtualCache[T] = new VoxelCollection({ controller: this.controller, fillVoxels: B.getFillVoxels(), origin: B.getOrigin() }) : (d === this.tokens.SUBTRACTION_OP || d === this.tokens.SYMM_DIFF_OP) && (this.virtualCache[T] = new VoxelCollection({ controller: this.controller, fillVoxels: [], origin: [0, 0, 0] })), this.virtualCache[T]; let D = B.jointBoundingBox.getAllJointBoundingBoxes(JointBoundingBoxActions.RETURN_MODE_FULL_DIRECTORY), $ = x.jointBoundingBox.getAllJointBoundingBoxes(JointBoundingBoxActions.RETURN_MODE_FULL_DIRECTORY), A = []; for (let I of D) for (let _ of $) { let P = BoundingBox.boundingBoxIntersect(I.boundingBoxPointData, _.boundingBoxPointData); P[0] && A.push(new BoundingBox({ boundingInputPayload: P[1], inputType: BoundingBoxPayloadModes.TYPE_BOUNDING_DIRECTORY })) } let R = new JointBoundingBox(A), p = [], V = [], y = [], L = B.getFillVoxels(), C = x.getFillVoxels(); for (let b of L) console.log("\nVoxel 1 in 2 " + JSON.stringify(b) + ": " + x.findPointFromObject(b)), R.isInside(b) && -1 !== x.findPointFromObject(b)[1] ? p.push(b) : V.push(b); for (let Y of C) console.log("\nVoxel 2 in 1 " + JSON.stringify(Y) + ": " + B.findPointFromObject(Y)), R.isInside(Y) && -1 !== B.findPointFromObject(Y)[1] || y.push(Y); let X = []; if (d === this.tokens.INTERSECTION_OP) { if (0 === p.length) return this.virtualCache[T] = new VoxelCollection({ controller: this.controller, fillVoxels: [], origin: [0, 0, 0] }), this.virtualCache[T]; X = p } else if (d === this.tokens.UNION_OP) BaseObject.push2D(V, X), BaseObject.push2D(y, X), BaseObject.push2D(p, X); else if (d === this.tokens.SUBTRACTION_OP) BaseObject.push2D(V, X); else if (d === this.tokens.SYMM_DIFF_OP) BaseObject.push2D(V, X), BaseObject.push2D(y, X); else throw ReferenceError("Unknown operation: " + d); return this.virtualCache[T] = new VoxelCollection({ controller: this.controller, origin: [0, 0, 0], fillVoxels: X }), this.virtualCache[T] } interpretAST () { this.tokens = SetOperationsParser.getSymbols(), this.resetVirtualCache(); let e = this.#e(this.equationInstance.getAST(), 0); return this._fillVoxels = e._fillVoxels, this.calculateBoundingBox(), e.delete(), this } } export class LayerVectorExtrude extends BaseObject { extrudeVector; extrudeObject; extrudeEndCap; shell; constructor(e) { super({ controller: e.controller, origin: e.origin }), this.extrudeVector = [...e.extrudeVector], this.extrudeObject = e.extrudeObject, this.extrudeEndCap = new Layer({ controller: e.controller, origin: e.origin, verticesArray: [] }), this.shell = !1 } changeExtrudeVector (e) { return this.extrudeVector = [...e], this._fillVoxels = this.extrudeObject.getFillVoxels(), this.extrudeEndCap.changeVertices([]), this.calculateBoundingBox(), this.shell = !1, this } changeExtrudeObject (e) { return this.extrudeObject = e, this._fillVoxels = this.extrudeObject.getFillVoxels(), this.extrudeEndCap.changeVertices([]), this.calculateBoundingBox(), this.shell = !1, this } extrudeVoxels (e) { if (this.shell = e, this.extrudeVector[0] + this.extrudeVector[1] + this.extrudeVector[2] === 0) return this._fillVoxels = this.extrudeObject.getFillVoxels(), this.calculateBoundingBox(), this.extrudeEndCap.changeVertices(this.extrudeObject.getVerticeVoxels()).generateEdges().fillPolygon(), this; this._fillVoxels = []; let i = []; for (let t of this.extrudeObject.getVerticeVoxels()) i.push(t.map((e, i) => e += this.extrudeVector[i])); if (this.extrudeEndCap.changeVertices(i).generateEdges().fillPolygon(), e) { let n = this.extrudeObject.getEdgeVoxels(); if (0 === n.length) throw console.warn("extrudeVoxels error dectected, printing layer:"), console.warn(this.extrudeObject), ReferenceError("LayerVectorExtrude layer " + this.extrudeObject.uuid + " has no voxels within the edge directory."); for (let o of n) BaseObject.push2D(BaseObject.graph3DParametric(...o, ...o.map((e, i) => e += this.extrudeVector[i])).slice(1, -1), this._fillVoxels); BaseObject.push2D(this.extrudeEndCap.getFillVoxels(), this._fillVoxels), BaseObject.push2D(this.extrudeObject.getFillVoxels(), this._fillVoxels) } else for (let s of this.extrudeObject.getFillVoxels()) BaseObject.push2D(BaseObject.graph3DParametric(...s, ...s.map((e, i) => e += this.extrudeVector[i])), this._fillVoxels); return this.calculateBoundingBox(), this } } export var LayerConvexExtrudeEdgeDirectoryOptions; !function (e) { e.RETURN_MODE_FULL_DIRECTORY = "RETURN_MODE_FULL_DIRECTORY", e.RETURN_MODE_VOXELS = "RETURN_MODE_VOXELS" }(LayerConvexExtrudeEdgeDirectoryOptions || (LayerConvexExtrudeEdgeDirectoryOptions = {})); export class LayerConvexExtrude extends BaseObject { shell; extrudeObjects; edgeDirectory; static #f = 180 / Math.PI; constructor(e) { super({ controller: e.controller, origin: e.origin }), this.extrudeObjects = e.extrudeObjects, this.edgeDirectory = {}, this.shell = !1 } static polarSort (e, i) { return e.sort((e, t) => { let n = Math.atan2(e[1] - i[1], e[0] - i[0]) * LayerConvexExtrude.#f; n += n < 0 ? 360 : 0; let o = Math.atan2(t[1] - i[1], t[0] - i[0]) * LayerConvexExtrude.#f; return n - (o += o < 0 ? 360 : 0) }) } static pointOrientation (e, i, t) { return (i[0] - e[0]) * (t[1] - e[1]) - (i[1] - e[1]) * (t[0] - e[0]) } static convexHull (e) { let i = [], t = BaseObject.push2D(e, []).sort((e, i) => e[0] - i[0]), n = t[0]; t = [n, ...LayerConvexExtrude.polarSort(t.splice(1, t.length), n)]; for (let o = 0; o < t.length; o++) { let s = t[o]; if (i.length > 1) for (; i.length > 1 && 0 >= LayerConvexExtrude.pointOrientation(i[1], i[0], s);)i.shift(); i.unshift(s) } return i } generateEdges (e) { this.resetEdgeDirectory(); let i = 0, t = new VoxelCollection({ controller: this.controller, origin: [0, 0, 0], fillVoxels: [] }), n = new CompositeVoxelCollection({ controller: this.controller, origin: [0, 0, 0], variableNames: {}, log: !1 }); for (let o = 0; o < this.extrudeObjects.length; o++)if (o + 1 < this.extrudeObjects.length) { let s = this.extrudeObjects[o], r = this.extrudeObjects[o + 1]; var l = new VoxelCollection({ controller: this.controller, origin: [0, 0, 0], fillVoxels: [] }); n.changeNames({ [l.uuid]: l, [t.uuid]: t }); let g = new VoxelCollection({ controller: this.controller, origin: [0, 0, 0], fillVoxels: r.getVerticeVoxels() }); n.changeNames({ [l.uuid]: l, [t.uuid]: t, [g.uuid]: g }).setEquation(g.uuid + n.tokens.SUBTRACTION_OP + l.uuid), l.addFillVoxels(n.interpretAST().getFillVoxels()), g.setFillVoxels(s.getVerticeVoxels()), l.addFillVoxels(n.interpretAST().getFillVoxels()), g.delete(), n.setEquation(t.uuid + n.tokens.SUBTRACTION_OP + l.uuid), t.setFillVoxels([]); let u = s.getVerticeVoxels(), a = r.getVerticeVoxels(); for (let B of u) for (let d of a) t.setFillVoxels(BaseObject.graph3DParametric(...B, ...d)), l.addFillVoxels(n.interpretAST().getFillVoxels()); let x = [], h; for (let N of Object.keys(l.sortedFillVoxelsDirectory)) { let O = BaseObject.deepCopy(l.sortedFillVoxelsDirectory[Number(N)]); h = l.boundingBoxMeta, O = O.map(e => e.filter((e, i) => i != h.biggestRangeIndex[0])), O = (O = LayerConvexExtrude.convexHull(O)).map(e => (e.splice(h.biggestRangeIndex[0], 0, Number(N)), e)), BaseObject.push2D(O, x) } if (l._fillVoxels = x, l.calculateBoundingBox(), this.edgeDirectory[i] = l, i++, e) { let E = new VoxelCollection({ controller: this.controller, origin: [0, 0, 0], fillVoxels: r.getEdgeVoxels() }); n.changeNames({ [l.uuid]: l, [E.uuid]: E }).setEquation(E.uuid + n.tokens.SUBTRACTION_OP + l.uuid), l.addFillVoxels(n.interpretAST().getFillVoxels()), E.setFillVoxels(s.getEdgeVoxels()), l.addFillVoxels(n.interpretAST().getFillVoxels()); let c = Object.keys(l.sortedFillVoxelsDirectory), T = BaseObject.push2D(l.sortedFillVoxelsDirectory[Number(c[0])], []); T = T.map(e => e.filter((e, i) => i != h.biggestRangeIndex[0])), T = (T = LayerConvexExtrude.convexHull(T)).map(e => (e.splice(h.biggestRangeIndex[0], 0, Number(c[0])), e)), E.delete(); let f = new Layer({ controller: this.controller, origin: [0, 0, 0], verticesArray: T }); n.changeNames({ [l.uuid]: l, [f.uuid]: f }).setEquation(f.uuid + n.tokens.SUBTRACTION_OP + l.uuid), f.generateEdges(), l.addFillVoxels(n.interpretAST().getFillVoxels()), T = (T = BaseObject.push2D(l.sortedFillVoxelsDirectory[Number(c[c.length - 1])], [])).map(e => e.filter((e, i) => i != h.biggestRangeIndex[0])), T = (T = LayerConvexExtrude.convexHull(T)).map(e => (e.splice(h.biggestRangeIndex[0], 0, Number(c[c.length - 1])), e)), f.changeVertices(T).generateEdges(), l.addFillVoxels(n.interpretAST().getFillVoxels()), f.delete() } } return n.delete(), t.delete(), this._fillVoxels = this.getEdgeDirectory(LayerConvexExtrudeEdgeDirectoryOptions.RETURN_MODE_VOXELS), this.calculateBoundingBox(), this } getEdgeDirectory (e) { if (e === LayerConvexExtrudeEdgeDirectoryOptions.RETURN_MODE_FULL_DIRECTORY) { let i = {}; for (let t of Object.keys(this.edgeDirectory)) i[Number(t)] = this.edgeDirectory[Number(t)].getFillVoxels(); return i } if (e === LayerConvexExtrudeEdgeDirectoryOptions.RETURN_MODE_VOXELS) { let n = [], o = new CompositeVoxelCollection({ controller: this.controller, origin: [0, 0, 0], variableNames: {}, log: !1 }), s = "", r = {}, l = Object.keys(this.edgeDirectory); for (let g = 0; g < l.length; g++) { let u = Number(l[g]); s += this.edgeDirectory[u].uuid, r[this.edgeDirectory[u].uuid] = this.edgeDirectory[u], g + 1 !== l.length && (s += o.tokens.UNION_OP) } return o.changeNames(r), BaseObject.push2D(o.setEquation(s).interpretAST().getFillVoxels(), n), o.delete(), n } throw ReferenceError("Invalid getEdgeDirectory mode, must be either 'RETURN_MODE_FULL_DIRECTORY' or 'RETURN_MODE_VOXELS'") } resetEdgeDirectory () { for (let e of (this.shell = !1, this._fillVoxels = [], Object.keys(this.edgeDirectory))) this.edgeDirectory[Number(e)].delete(), delete this.edgeDirectory[Number(e)]; return this } }